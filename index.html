<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Редактор базових станцій</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            font-family: Tahoma, sans-serif;
            font-size: 12px;
        }

        #map {
            flex: 1;
        }

        #sidebar {
            height: 100vh;
            /* Розтягуємо бічну панель зверху донизу */
            width: 300px;
            background: #f4f4f4;
            padding: 10px;
            overflow-y: auto;
            border-right: 1px solid #ccc;
            transition: transform 0.3s ease, width 0.3s ease;
            /* Додаємо анімацію ширини */
            font-family: Tahoma, sans-serif;
        }

        #sidebar.collapsed {
            transform: translateX(-100%);
            width: 0;
            /* Повністю згортаємо ширину */
            padding: 0;
            /* Прибираємо відступи при згортанні */
            border-right: none;
            /* Прибираємо межу при згортанні */
        }

        #button-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }
        
        #button-container button {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-family: Tahoma, sans-serif;
        }

        #toggle-sidebar {
            background: #007bff;
            color: white;
        }

        #delete-all {
            background: #dc3545;
            color: white;
        }

        .station-item {
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #fff;
            font-family: Tahoma, sans-serif;
            font-size: 12px;
        }

        .station-item input,
        .station-item button {
            margin: 5px 0;
            font-size: 12px;
        }

        .leaflet-popup-content-wrapper {
            background: rgba(255, 255, 255, 0.2); /* White with 20% opacity */
            border: none;
            border-radius: 8px;
            padding: 0;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .leaflet-popup-content {
            font-size: 14px;
            margin: 0;
            cursor: move;
            padding: 5px;
        }

        .leaflet-popup-tip-container {
            display: none;
        }

        .info-box {
            /* Стиль інфо бокса і текста у ньому*/
            background: rgba(255, 255, 255, 0.2); /* White with 20% opacity */
            border: 1px solid #000; /* Solid border with no transparency */
            border-radius: 8px;
            padding: 5px;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 12px;
            text-align: left;
            min-width: 200px;
            max-width: 300px;
            z-index: 1000;
            font-family: Tahoma, sans-serif;
            font-weight: normal;
            color: black; /* Ensure text remains fully opaque */
        }

        .info-box-container {
            z-index: 1000 !important;
        }

        .default-settings {
            background: #fff;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 12px;
        }

        .default-settings h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            text-align: center; /* Center horizontally */
        }

        .setting-item {
            margin-bottom: 8px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 3px;
            font-size: 12px;
            font-family: Tahoma, sans-serif;
        }

        .setting-item input[type="number"],
        .setting-item input[type="color"] {
            width: 100%;
            padding: 3px;
            font-size: 12px;
        }

        .setting-item .checkbox-group {
            display: flex;
            gap: 15px;
        }

        .setting-item .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #sidebar h3 {
            font-size: 16px;
            text-align: center; /* Center horizontally */
        }

        #sidebar h4 {
            font-size: 14px;
        }

        .checkbox-item label {
            font-size: 12px;
        }

        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 12px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        /* Стилі для кнопок видалення */
        .delete-button,
        #delete-all {
            background-color: #f44336;
        }

        .delete-button:hover,
        #delete-all:hover {
            background-color: #d32f2f;
        }

        /* Покращення стилів для інпутів */
        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 6px 10px;
            margin: 4px 0;
            display: inline-block;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        input[type="color"] {
            width: 100%;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        /* Покращення стилів для станцій у списку */
        .station-item {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.3s;
        }

        .station-item:hover {
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Заголовок для кожної станції */
        .station-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: bold;
        }

        /* Групування налаштувань */
        .settings-group {
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #f9f9f9;
        }

        .settings-group h5 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #555;
        }

        /* Адаптивний дизайн */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #sidebar {
                width: 100%;
                height: 300px;
                border-right: none;
                border-bottom: 1px solid #ccc;
            }

            #sidebar.collapsed {
                transform: translateY(-100%);
                height: 0;
            }

            #button-container {
                top: 10px;
                left: 10px;
                position: absolute;
            }
        }

        /* Покращення стилів для інфобоксів */
        .info-box {
            background: rgba(255, 255, 255, 0.6); /* White with 60% opacity */
            border: 1px solid #000; /* Solid border with no transparency */
            border-radius: 8px;
            padding: 8px;
            cursor: move;
            user-select: none;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            font-size: 12px;
            text-align: left;
            color: black; /* Ensuring text is fully opaque */
            min-width: 200px;
            max-width: 300px;
            z-index: 1000;
            font-family: Tahoma, sans-serif;
            font-weight: normal;
            transition: box-shadow 0.3s;
            line-height: normal; /* Normal line height for better readability */
        }

        .info-box:hover {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Стилі для кнопок збереження/завантаження */
        .save-load-buttons {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .save-load-buttons button {
            flex: 1;
            margin: 0 5px;
            background-color: #2196F3;
        }

        .save-load-buttons button:hover {
            background-color: #0b7dda;
        }

        #button-container {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: flex-start;
        }

        #button-container button {
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 5px;
            cursor: pointer;
        }

        #geocode-indicator {
            position: absolute;
            top: 50%;
            left: calc(50% + 150px); /* Adjust for sidebar width */
            transform: translate(-50%, -50%);
            z-index: 1000;
            display: none; /* Hidden by default */
            transition: left 0.3s ease; /* Smooth transition when sidebar toggles */
        }

        .spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }

        .spinner div {
            width: 10px;
            height: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            animation: bounce 1.5s infinite ease-in-out;
        }

        .spinner div:nth-child(1) {
            animation-delay: -0.3s;
        }

        .spinner div:nth-child(2) {
            animation-delay: -0.15s;
        }

        .spinner div:nth-child(3) {
            animation-delay: 0s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }

        .spinner-circle {
            position: relative;
            width: 50px;
            height: 50px;
        }

        .spinner-circle div {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            animation: spinner-circle 1.2s linear infinite;
        }

        .spinner-circle div:nth-child(1) {
            top: 0;
            left: 50%;
            transform: translate(-50%, 0);
            animation-delay: -1.1s;
        }

        .spinner-circle div:nth-child(2) {
            top: 14%;
            left: 85%;
            transform: translate(-50%, -50%);
            animation-delay: -1s;
        }

        .spinner-circle div:nth-child(3) {
            top: 50%;
            left: 100%;
            transform: translate(-50%, -50%);
            animation-delay: -0.9s;
        }

        .spinner-circle div:nth-child(4) {
            top: 85%;
            left: 85%;
            transform: translate(-50%, -50%);
            animation-delay: -0.8s;
        }

        .spinner-circle div:nth-child(5) {
            top: 100%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation-delay: -0.7s;
        }

        .spinner-circle div:nth-child(6) {
            top: 85%;
            left: 14%;
            transform: translate(-50%, -50%);
            animation-delay: -0.6s;
        }

        .spinner-circle div:nth-child(7) {
            top: 50%;
            left: 0;
            transform: translate(-50%, -50%);
            animation-delay: -0.5s;
        }

        .spinner-circle div:nth-child(8) {
            top: 14%;
            left: 14%;
            transform: translate(-50%, -50%);
            animation-delay: -0.4s;
        }

        @keyframes spinner-circle {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(0.5);
                opacity: 0.3;
            }
        }
    </style>
</head>

<body>
    <div id="sidebar">
        <h3>Редактор базових станцій</h3>
        <div class="default-settings">
            <h4>Налаштування за замовчуванням</h4>
            <div class="setting-item">
                <label>Розмір тексту (px):</label>
                <input type="number" id="default-font-size" value="12" min="6" max="20">
            </div>
            <div class="setting-item">
                <label>Колір азимутів:</label>
                <input type="color" id="default-color" value="#000000">
            </div>
            <div class="setting-item">
                <label>Радіус азимутів (м):</label>
                <input type="number" id="default-radius" value="700" min="100" max="90000" step="50">
            </div>
            <div class="setting-item">
                <label>Ширина азимутів (°):</label>
                <input type="number" id="default-width" value="120" min="30" max="360" step="5">
            </div>
            <div class="setting-item">
                <label>Відступ інфобокса (м):</label>
                <input type="number" id="default-popup-distance" value="250" min="50" max="500" step="10">
            </div>
            <div class="setting-item">
                <label>Геокодувати нові станції:</label>
                <div class="checkbox-item">
                    <input type="checkbox" id="default-geocode" checked>
                    <label for="default-geocode">Так</label>
                </div>
            </div>
            <div class="setting-item">
                <label>Стиль тексту:</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="default-bold">
                        <label for="default-bold">Жирний</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="default-italic">
                        <label for="default-italic">Курсив</label>
                    </div>
                </div>
            </div>
        </div>
        <div id="station-list"></div>
    </div>
    <div id="map">
        <div id="button-container">
            <button id="delete-all">Видалити все</button>
            <button id="toggle-sidebar">Згорнути панель</button>
        </div>
    </div>
    <div id="geocode-indicator">
        <div class="spinner-circle">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <script>

        // Глобальний прапорець для відстеження нещодавніх операцій перетягування
        let isRecentlyDragged = false;

        // Ініціалізація функціоналу пошуку та геокодування з використанням Nominatim API
        function initGeocoding() {
            // Створення елементів інтерфейсу для пошуку
            const searchContainer = document.createElement('div');
            searchContainer.className = 'search-container';
            searchContainer.style.position = 'absolute';
            searchContainer.style.top = '10px';
            searchContainer.style.right = '10px';
            searchContainer.style.zIndex = '1000';
            searchContainer.style.width = '300px';

            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.id = 'search-input';
            searchInput.placeholder = 'Пошук адреси...';
            searchInput.style.width = '100%';
            searchInput.style.padding = '8px';
            searchInput.style.borderRadius = '4px';
            searchInput.style.border = '1px solid #ccc';
            searchInput.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';

            const searchResults = document.createElement('div');
            searchResults.id = 'search-results';
            searchResults.style.backgroundColor = 'white';
            searchResults.style.maxHeight = '300px';
            searchResults.style.overflowY = 'auto';
            searchResults.style.marginTop = '5px';
            searchResults.style.borderRadius = '4px';
            searchResults.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
            searchResults.style.display = 'none';

            searchContainer.appendChild(searchInput);
            searchContainer.appendChild(searchResults);
            document.body.appendChild(searchContainer);

            // Обробник події для введення тексту в поле пошуку
            let searchTimeout;
            searchInput.addEventListener('input', function () {
                clearTimeout(searchTimeout);
                const query = this.value.trim();

                if (query.length < 3) {
                    searchResults.style.display = 'none';
                    return;
                }

                // Затримка пошуку на 2 секунди після завершення введення
                searchTimeout = setTimeout(() => {
                    searchAddress(query);
                }, 2000);
            });

            // Функція для пошуку адреси через Nominatim API
            function searchAddress(query) {
                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5`;

                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP помилка! статус: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        searchResults.innerHTML = '';

                        if (data.length === 0) {
                            searchResults.innerHTML = '<div class="search-item">Нічого не знайдено</div>';
                            searchResults.style.display = 'block';
                            return;
                        }

                        // Відображення результатів пошуку
                        data.forEach(item => {
                            const resultItem = document.createElement('div');
                            resultItem.className = 'search-item';
                            resultItem.textContent = item.display_name;
                            resultItem.style.padding = '8px';
                            resultItem.style.borderBottom = '1px solid #eee';
                            resultItem.style.cursor = 'pointer';

                            resultItem.addEventListener('mouseover', function () {
                                this.style.backgroundColor = '#f0f0f0';
                            });

                            resultItem.addEventListener('mouseout', function () {
                                this.style.backgroundColor = 'white';
                            });

                            // Додавання маркера базової станції при виборі результату
                            resultItem.addEventListener('click', function () {
                                const lat = parseFloat(item.lat);
                                const lng = parseFloat(item.lon);

                                // Переміщення карти до знайденої локації
                                map.setView([lat, lng], 16);

                                // Додавання маркера базової станції
                                if (document.getElementById('default-geocode').checked) {
                                    addStation(lat, lng, 0, DEFAULT_CONFIG.RADIUS, DEFAULT_CONFIG.AZIMUTH_WIDTH, DEFAULT_CONFIG.COLOR, item.display_name);
                                } else {
                                    addStation(lat, lng);
                                }

                                // Очищення пошуку після завершення
                                setTimeout(() => {
                                    searchInput.value = '';
                                    searchResults.style.display = 'none';
                                }, 0);
                            });

                            searchResults.appendChild(resultItem);
                        });

                        searchResults.style.display = 'block';
                    })
                    .catch(error => {
                        console.error('Помилка пошуку:', error);
                        searchResults.innerHTML = '<div class="search-item">Помилка пошуку</div>';
                        searchResults.style.display = 'block';
                    });
            }

            // Закриття результатів пошуку при кліку поза ними
            document.addEventListener('click', function (e) {
                if (!searchContainer.contains(e.target)) {
                    searchResults.style.display = 'none';
                }
            });
        }

        // Функція для зворотного геокодування (отримання адреси за координатами)
        const geocodeCache = new Map();

        async function reverseGeocode(lat, lng) {
            const key = `${lat.toFixed(6)},${lng.toFixed(6)}`; // Зменшення точності для уникнення дублювання
            if (geocodeCache.has(key)) {
                return geocodeCache.get(key);
            }

            const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`;
            const indicator = document.getElementById('geocode-indicator');
            try {
                indicator.style.display = 'flex'; // Показуємо індикатор
                const response = await fetch(url);
                const data = await response.json();
                const address = data?.address ? [
                    data.address.state,
                    data.address.county,
                    data.address.city || data.address.town || data.address.village || '',
                    data.address.road,
                    data.address.house_number
                ].filter(Boolean).join(', ') : '';
                geocodeCache.set(key, address);
                return address;
            } catch (error) {
                console.error('Помилка зворотного геокодування:', error);
                return '';
            } finally {
                indicator.style.display = 'none'; // Ховаємо індикатор
            }
        }

        // Модифікація обробника кліку на карті для автоматичного заповнення адреси
        function enhanceMapClickHandler() {
            map.off('click'); // Видалення всіх попередніх обробників
            map.on('click', async function (e) {
                const { lat, lng } = e.latlng;
                const address = document.getElementById('default-geocode').checked
                    ? await reverseGeocode(lat, lng) // Використання кешу для уникнення зайвих запитів
                    : '';
                addStation(lat, lng, 0, DEFAULT_CONFIG.RADIUS, DEFAULT_CONFIG.AZIMUTH_WIDTH, DEFAULT_CONFIG.COLOR, address);
            });
        }

        // Ініціалізація функціоналу геокодування
        document.addEventListener('DOMContentLoaded', function () {
            initGeocoding();
            enhanceMapClickHandler();
        });

        // Функція для серіалізації даних станцій
        function serializeStations() {
            return stations.map(station => ({
                lat: station.lat,
                lng: station.lng,
                azimuth: station.azimuth,
                radius: station.radius,
                width: station.width,
                color: station.color,
                address: station.address,
                popupLat: station.popupLat,
                popupLng: station.popupLng
            }));
        }

        // Функція для збереження даних у файл
        function saveStations(e) {
            if (e) e.stopPropagation(); // Запобігання спливанню події
            
            const data = serializeStations();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'base_stations.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Функція для завантаження даних із файлу
        function loadStations(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                e.stopPropagation(); // Запобігання спливанню події
                
                try {
                    const data = JSON.parse(e.target.result);
                    // Видалення існуючих станцій
                    stations.forEach(station => {
                        map.removeLayer(station.marker);
                        map.removeLayer(station.polygon);
                        map.removeLayer(station.popupMarker);
                    });
                    stations.length = 0;
                    // Додавання завантажених станцій
                    data.forEach(stationData => {
                        addStation(
                            stationData.lat,
                            stationData.lng,
                            stationData.azimuth,
                            stationData.radius,
                            stationData.width,
                            stationData.color,
                            stationData.address
                        );
                        // Встановлення позиції інфобокса, якщо вона була збережена
                        if (stationData.popupLat && stationData.popupLng) {
                            const lastIndex = stations.length - 1;
                            stations[lastIndex].popupLat = stationData.popupLat;
                            stations[lastIndex].popupLng = stationData.popupLng;
                            stations[lastIndex].popupMarker.setLatLng([stationData.popupLat, stationData.popupLng]);
                        }
                    });
                    updateStationList();
                    alert('Дані успішно завантажено');
                } catch (error) {
                    alert('Помилка при завантаженні файлу: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Додавання кнопок збереження та завантаження
        function addSaveLoadButtons() {
            const sidebar = document.getElementById('sidebar');
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'save-load-buttons';
            buttonContainer.style.marginBottom = '15px';
            // Кнопка збереження
            const saveButton = document.createElement('button');
            saveButton.textContent = 'Зберегти дані';
            saveButton.style.marginRight = '10px';
            saveButton.style.padding = '5px 10px';
            saveButton.addEventListener('click', saveStations);
            // Кнопка завантаження
            const loadButton = document.createElement('button');
            loadButton.textContent = 'Завантажити дані';
            loadButton.style.padding = '5px 10px';
            // Прихований input для вибору файлу
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';
            fileInput.style.display = 'none';
            fileInput.addEventListener('change', (e) => {
                e.stopPropagation(); // Запобігання спливанню події
                if (e.target.files.length > 0) {
                    loadStations(e.target.files[0]);
                }
            });
            loadButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Запобігання спливанню події
                fileInput.click();
            });

            buttonContainer.appendChild(saveButton);
            buttonContainer.appendChild(loadButton);
            buttonContainer.appendChild(fileInput);
            // Вставлення кнопок після заголовка
            const title = sidebar.querySelector('h3');
            title.parentNode.insertBefore(buttonContainer, title.nextSibling);
        }

        // Ініціалізація функціоналу збереження/завантаження
        document.addEventListener('DOMContentLoaded', addSaveLoadButtons);
        const map = L.map('map').setView([50.4501, 30.5234], 14); // Центр Києва
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
        }).addTo(map);

        // Константи
        const DEFAULT_CONFIG = {
            AZIMUTH_WIDTH: 120,
            RADIUS: 700,
            COLOR: '#000000',
            POPUP_DISTANCE: 250, // Відступ інфобокса по замовчуванню
            FONT_SIZE: 12,
            FONT_WEIGHT: 'normal',
            FONT_STYLE: 'normal'
        };

        // Кешуємо DOM елементи
        const DOM = {
            stationList: document.getElementById('station-list'),
            toggleSidebar: document.getElementById('toggle-sidebar'),
            deleteAll: document.getElementById('delete-all'),
            sidebar: document.getElementById('sidebar'),
            defaultFontSize: document.getElementById('default-font-size'),
            defaultColor: document.getElementById('default-color'),
            defaultBold: document.getElementById('default-bold'),
            defaultItalic: document.getElementById('default-italic'),
            defaultRadius: document.getElementById('default-radius'),
            defaultWidth: document.getElementById('default-width'),
            defaultPopupDistance: document.getElementById('default-popup-distance'),
            defaultGeocode: document.getElementById('default-geocode')
        };

        const stations = [];

        // Допоміжні функції
        const calculatePopupPosition = (lat, lng, azimuth) => {
            const oppositeAzimuth = (azimuth + 180) % 360;
            const latOffset = (DEFAULT_CONFIG.POPUP_DISTANCE / 111320) * Math.cos(oppositeAzimuth * (Math.PI / 180));
            const lngOffset = (DEFAULT_CONFIG.POPUP_DISTANCE / (111320 * Math.cos(lat * (Math.PI / 180)))) * Math.sin(oppositeAzimuth * (Math.PI / 180));
            return {
                lat: lat + latOffset,
                lng: lng + lngOffset
            };
        };

        function createAzimuthPolygon(lat, lng, azimuth, radius, width, color) {
            if (width === 360) {
                // If width is 360, create a circle
                return L.circle([lat, lng], {
                    radius: radius,
                    color: color,
                    fillColor: color,
                    fillOpacity: 0.3, // Set opacity to 30%
                    weight: 1
                });
            }
            const startAngle = (azimuth - width / 2) * (Math.PI / 180);
            const endAngle = (azimuth + width / 2) * (Math.PI / 180);
            const points = [[lat, lng]];
            const step = Math.PI / 180;
            for (let angle = startAngle; angle <= endAngle; angle += step) {
                const pointLat = lat + (radius / 111320) * Math.cos(angle);
                const pointLng = lng + (radius / (111320 * Math.cos(lat * (Math.PI / 180)))) * Math.sin(angle);
                points.push([pointLat, pointLng]);
            }
            points.push([lat, lng]); // Замикаємо полігон
            return L.polygon(points, { color, fillColor: color, fillOpacity: 0.2, weight: 1 }); // Set opacity to 30%
        }

        function createPopup(address, azimuth, color) {
            const div = document.createElement('div');
            div.className = 'info-box';
            div.style.fontSize = `${DEFAULT_CONFIG.FONT_SIZE}px`;
            div.style.fontWeight = DEFAULT_CONFIG.FONT_WEIGHT;
            div.style.fontStyle = DEFAULT_CONFIG.FONT_STYLE;
            div.style.borderColor = color;
            div.style.opacity = '1'; // Set overall opacity to 100%
            div.style.lineHeight = 'normal'; // Use normal line height
            div.innerHTML = `
                <div style="border-color: ${color};">Адреса: ${address}</div>
                <div style="border-color: ${color};">Азимут: ${azimuth}°</div>
            `;
            return L.divIcon({
                html: div,
                className: 'info-box-container',
                iconSize: [200, 50],
                iconAnchor: [100, 25]
            });
        }

        function setupPopupDragging(popup, station) {
            const marker = L.marker([station.popupLat, station.popupLng], {
                icon: popup,
                draggable: true,
                zIndexOffset: 1000
            }).addTo(map);
            marker.on('drag', (e) => {
                const { lat, lng } = e.target.getLatLng();
                station.popupLat = lat;
                station.popupLng = lng;
            });
            marker.on('dragend', () => {
                isRecentlyDragged = true; // Set flag for popup dragging too
                setTimeout(() => {
                    isRecentlyDragged = false;
                }, 300); // Reset flag after short period to prevent accidental station creation
            });
            return marker;
        }

        function addStation(lat, lng, azimuth = 0, radius = DEFAULT_CONFIG.RADIUS,
            width = DEFAULT_CONFIG.AZIMUTH_WIDTH, color = DEFAULT_CONFIG.COLOR,
            address = '', icon = 'default') {
            const station = {
                lat,
                lng,
                azimuth,
                radius,
                width,
                color: color || DEFAULT_CONFIG.COLOR,
                address,
                icon,
                marker: null,
                polygon: null,
                popup: null,
                popupMarker: null,
                popupLat: null,
                popupLng: null,
            };

            // Додаємо маркер
            const createCustomIcon = (color) => L.divIcon({
                className: 'custom-marker',
                html: `
                    <div style="
                        width: 14px; /* Зменшено на 30% від 20px */
                        height: 14px; /* Зменшено на 30% від 20px */
                        background: ${color};
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border: 2px solid white;">
                        <div style="
                            width: 6px; /* Виправлено розмір для центрування */
                            height: 6px; /* Виправлено розмір для центрування */
                            background: white;
                            border-radius: 50%;"></div>
                    </div>
                `,
                iconSize: [14, 14], /* Зменшено на 30% від [20, 20] */
                iconAnchor: [7, 7] /* Зменшено на 30% від [10, 10] */
            });

            station.marker = L.marker([lat, lng], { draggable: true, icon: createCustomIcon(color) }).addTo(map);
            setupStationDragging(station);

            // Додаємо полігон
            station.polygon = createAzimuthPolygon(lat, lng, azimuth, radius, width, color);
            station.polygon.addTo(map);

            // Налаштовуємо popup
            const popupPos = calculatePopupPosition(lat, lng, azimuth);
            station.popupLat = popupPos.lat;
            station.popupLng = popupPos.lng;
            station.popup = createPopup(address, azimuth, color);
            station.popupMarker = setupPopupDragging(station.popup, station);

            stations.push(station);
            updateStationList();
            updatePopupStyle(station);
        }

        // Function to set up dragging for the station marker and polygon without triggering geocoding
        function setupStationDragging(station) {
            // Make the station marker draggable
            station.marker.on('drag', (e) => {
                const { lat, lng } = e.target.getLatLng();
                station.lat = lat;
                station.lng = lng;

                // Update popup position relative to the new station position
                const latOffset = station.popupLat - station.lat;
                const lngOffset = station.popupLng - station.lng;
                station.popupLat = lat + latOffset;
                station.popupLng = lng + lngOffset;

                station.popupMarker.setLatLng([station.popupLat, station.popupLng]);
                updateStationPolygon(station); // Update azimuth polygon position
            });

            // When drag ends, update the station list to reflect new position
            station.marker.on('dragend', () => {
                isRecentlyDragged = true; // Set flag indicating recent drag activity
                setTimeout(() => {
                    isRecentlyDragged = false;
                }, 300); // Reset flag after short period to prevent accidental station creation
                updateStationList();
            });
        }

        function updateStationPolygon(station) {
            // Remove the old polygon
            map.removeLayer(station.polygon);

            // Create and add the updated polygon
            station.polygon = createAzimuthPolygon(
                station.lat,
                station.lng,
                station.azimuth,
                station.radius,
                station.width,
                station.color
            );
            station.polygon.addTo(map);
        }

        function updatePopupPosition(station) {
            // Calculate the new popup position
            const popupPos = calculatePopupPosition(station.lat, station.lng, station.azimuth);
            station.popupLat = popupPos.lat;
            station.popupLng = popupPos.lng;

            // Update the popup marker's position
            station.popupMarker.setLatLng([station.popupLat, station.popupLng]);
        }

        function updatePopupStyle(station) {
            const popupElement = station.popupMarker.getElement();
            if (popupElement) {
                const infoBox = popupElement.querySelector('.info-box');
                if (infoBox) {
                    infoBox.style.padding = '5px';
                    infoBox.style.borderColor = station.color;
                    infoBox.style.opacity = '1'; // Ensure full opacity
                }
            }
        }

        function createStationListItem(station, index) {
            const item = document.createElement('div');
            item.className = 'station-item';
            item.innerHTML = `
                <label>Адреса:</label>
                <input type="text" value="${station.address}" data-index="${index}" class="address-input" />
                <label>Радіус (м):</label>
                <input type="number" value="${station.radius}" data-index="${index}" class="radius-input" />
                <label>Азимут (0-360°):</label>
                <input type="number" min="0" max="360" value="${station.azimuth}" data-index="${index}" class="azimuth-input" />
                <label>Ширина (0-360°):</label>
                <input type="number" value="${station.width}" data-index="${index}" class="width-input" />
                <label>Колір:</label>
                <input type="color" value="${station.color}" data-index="${index}" class="color-input" />
                <button data-index="${index}" class="delete-button">Видалити</button>
            `;
            return item;
        }

        function updateStationList() {
            const fragment = document.createDocumentFragment();
            stations.forEach((station, index) => {
                fragment.appendChild(createStationListItem(station, index));
            });
            DOM.stationList.innerHTML = ''; // Clear existing list
            DOM.stationList.appendChild(fragment); // Append all at once
        }

        // Обробники подій
        document.getElementById('station-list').addEventListener('input', (e) => {
            e.stopPropagation(); // Prevent event bubbling to map
            
            const index = e.target.dataset.index;
            const station = stations[index];
            switch (e.target.className) {
                case 'address-input':
                    station.address = e.target.value;
                    station.popup = createPopup(e.target.value, station.azimuth, station.color);
                    station.popupMarker.setIcon(station.popup);
                    break;
                case 'azimuth-input':
                    const azimuthValue = parseFloat(e.target.value);
                    if (isNaN(azimuthValue) || azimuthValue < 0 || azimuthValue > 360) {
                        // Reset to previous valid value
                        e.target.value = station.azimuth;
                        alert('Азимут має бути в діапазоні від 0 до 360 градусів.');
                    } else {
                        station.azimuth = azimuthValue;
                        updateStationPolygon(station);
                        station.popup = createPopup(station.address, station.azimuth, station.color);
                        station.popupMarker.setIcon(station.popup);
                    }
                    break;
                case 'radius-input':
                    station.radius = parseFloat(e.target.value);
                    updateStationPolygon(station);
                    break;
                case 'width-input':
                    const widthValue = parseFloat(e.target.value);
                    if (isNaN(widthValue) || widthValue < 0 || widthValue > 360) {0
                        // Reset to previous valid value
                        e.target.value = station.width;
                        alert('Ширина азимуту має бути в діапазоні від 0 до 360 градусів.');
                    } else {
                        station.width = widthValue;
                        updateStationPolygon(station);
                    }
                    break;
                case 'color-input':
                    station.color = e.target.value;
                    updateStationPolygon(station);

                    // Update marker color
                    const newIcon = L.divIcon({
                        className: 'custom-marker',
                        html: `
                            <div style="
                                width: 14px; /* Зменшено на 30% від 20px */
                                height: 14px; /* Зменшено на 30% від 20px */
                                background: ${station.color};
                                border-radius: 50%;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                border: 2px solid white;">
                                <div style="
                                    width: 6px; /* Виправлено розмір для центрування */
                                    height: 6px; /* Виправлено розмір для центрування */
                                    background: white;
                                    border-radius: 50%;"></div>
                            </div>
                        `,
                        iconSize: [14, 14], /* Зменшено на 30% від [20, 20] */
                        iconAnchor: [7, 7] /* Зменшено на 30% від [10, 10] */
                    });
                    station.marker.setIcon(newIcon);

                    // Update popup border color
                    const popupElement = station.popupMarker.getElement();
                    if (popupElement) {
                        const infoBox = popupElement.querySelector('.info-box');
                        if (infoBox) {
                            infoBox.style.borderColor = station.color;
                        }
                    }
                    break;
            }
        });

        document.getElementById('station-list').addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event bubbling to map
            
            if (e.target.classList.contains('delete-button')) {
                const index = e.target.dataset.index;
                map.removeLayer(stations[index].marker);
                map.removeLayer(stations[index].polygon);
                map.removeLayer(stations[index].popupMarker);
                stations.splice(index, 1);
                updateStationList();
            }
        });

        map.on('click', async function (e) {
            // Check if the click originated from a UI element or after a recent drag
            if (e.originalEvent.target.closest('#sidebar') || 
                e.originalEvent.target.closest('#button-container') ||
                e.originalEvent.target.closest('.leaflet-control') ||
                e.originalEvent.target.closest('.info-box') ||
                e.originalEvent.target.closest('.search-container') ||
                isRecentlyDragged) {
                return; // Don't add station if clicking on UI elements or after dragging
            }

            // Prevent adding a new station if the click is near an existing station
            const { lat, lng } = e.latlng;
            const isNearExistingStation = stations.some(station => {
                const distance = map.distance([station.lat, station.lng], [lat, lng]);
                return distance < 50; // Adjusted threshold in meters to avoid duplicate stations
            });

            if (isNearExistingStation) {
                return; // Do not create a new station
            }

            // Show geocoding indicator if geocoding is enabled
            const geocodeEnabled = document.getElementById('default-geocode').checked;
            const indicator = document.getElementById('geocode-indicator');
            
            if (geocodeEnabled) {
                indicator.style.display = 'block';
            }
            
            // Get address only if geocoding is enabled
            const address = geocodeEnabled ? await reverseGeocode(lat, lng) : '';
            
            // Hide indicator after geocoding
            indicator.style.display = 'none';

            // Add station with obtained address
            const defaultAzimuth = 0; // Valid default value in range 0-360
            addStation(lat, lng, defaultAzimuth, DEFAULT_CONFIG.RADIUS, DEFAULT_CONFIG.AZIMUTH_WIDTH, DEFAULT_CONFIG.COLOR, address);
        });

        map.on('zoomend', () => {
            stations.forEach(updatePopupStyle);
        });

        function handleToggleSidebar(e) {
            if (e) e.stopPropagation(); // Prevent event bubbling
            DOM.sidebar.classList.toggle('collapsed');
            DOM.toggleSidebar.textContent = DOM.sidebar.classList.contains('collapsed')
                ? 'Розгорнути панель'
                : 'Згорнути панель';

            // Adjust geocode-indicator position
            const indicator = document.getElementById('geocode-indicator');
            if (DOM.sidebar.classList.contains('collapsed')) {
                indicator.style.left = '50%'; // Center without sidebar
            } else {
                indicator.style.left = 'calc(50% + 150px)'; // Center with sidebar
            }

            setTimeout(() => map.invalidateSize(), 300); // Ensure correct map size
        }

        function handleDeleteAll(e) {
            if (e) e.stopPropagation(); // Prevent event bubbling
            stations.forEach(station => {
                map.removeLayer(station.marker);
                map.removeLayer(station.polygon);
                map.removeLayer(station.popupMarker);
            });
            stations.length = 0;
            updateStationList();
        }

        DOM.toggleSidebar.addEventListener('click', handleToggleSidebar);
        DOM.deleteAll.addEventListener('click', handleDeleteAll);

        // Оновлюємо налаштування за замовчуванням
        DOM.defaultFontSize.addEventListener('change', (e) => {
            e.stopPropagation(); // Prevent event bubbling to map
            
            DEFAULT_CONFIG.FONT_SIZE = parseInt(e.target.value);
            stations.forEach(station => {
                const popupElement = station.popupMarker.getElement();
                if (popupElement) {
                    const infoBox = popupElement.querySelector('.info-box');
                    if (infoBox) {
                        infoBox.style.fontSize = `${DEFAULT_CONFIG.FONT_SIZE}px`;
                    }
                }
            });
        });

        DOM.defaultColor.addEventListener('input', (e) => {
            e.stopPropagation(); // Prevent event bubbling to map
            
            DEFAULT_CONFIG.COLOR = e.target.value;
            stations.forEach(station => {
                station.color = DEFAULT_CONFIG.COLOR;
                updateStationPolygon(station);
                // Update marker color
                const newIcon = L.divIcon({
                    className: 'custom-marker',
                    html: `
                        <div style="
                            width: 14px; /* Зменшено на 30% від 20px */
                            height: 14px; /* Зменшено на 30% від 20px */
                            background: ${DEFAULT_CONFIG.COLOR};
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            border: 2px solid white;">
                            <div style="
                                width: 6px; /* Виправлено розмір для центрування */
                                height: 6px; /* Виправлено розмір для центрування */
                                background: white;
                                border-radius: 50%;"></div>
                        </div>
                    `,
                    iconSize: [14, 14], /* Зменшено на 30% від [20, 20] */
                    iconAnchor: [7, 7] /* Зменшено на 30% від [10, 10] */
                });
                station.marker.setIcon(newIcon);

                // Update popup border color
                const popupElement = station.popupMarker.getElement();
                if (popupElement) {
                    const infoBox = popupElement.querySelector('.info-box');
                    if (infoBox) {
                        infoBox.style.borderColor = DEFAULT_CONFIG.COLOR;
                    }
                }
            });

            // Оновлення кольору прямокутника вибору кольору в налаштуваннях базових станцій
            document.querySelectorAll('.color-input').forEach(input => {
                input.value = DEFAULT_CONFIG.COLOR;
            });
        });

        DOM.defaultRadius.addEventListener('change', (e) => {
            e.stopPropagation(); // Prevent event bubbling to map
            
            DEFAULT_CONFIG.RADIUS = parseInt(e.target.value);
            stations.forEach(station => {
                station.radius = DEFAULT_CONFIG.RADIUS;
                updateStationPolygon(station);
            });
        });

        DOM.defaultWidth.addEventListener('change', (e) => {
            e.stopPropagation(); // Prevent event bubbling to map
            
            const newWidth = parseInt(e.target.value);
            if (isNaN(newWidth) || newWidth < 0 || newWidth > 360) {
                // Reset to previous valid value
                e.target.value = DEFAULT_CONFIG.AZIMUTH_WIDTH;
                alert('Ширина азимуту має бути в діапазоні від 0 до 360 градусів.');
            } else {
                DEFAULT_CONFIG.AZIMUTH_WIDTH = newWidth;
                stations.forEach(station => {
                    station.width = DEFAULT_CONFIG.AZIMUTH_WIDTH;
                    updateStationPolygon(station);
                });
            }
        });

        DOM.defaultPopupDistance.addEventListener('change', (e) => {
            e.stopPropagation(); // Prevent event bubbling to map
            
            DEFAULT_CONFIG.POPUP_DISTANCE = parseInt(e.target.value);
            stations.forEach(station => {
                const popupPos = calculatePopupPosition(station.lat, station.lng, station.azimuth);
                station.popupLat = popupPos.lat;
                station.popupLng = popupPos.lng;
                station.popupMarker.setLatLng([station.popupLat, station.popupLng]);
            });
        });

        DOM.defaultBold.addEventListener('change', (e) => {
            e.stopPropagation(); // Prevent event bubbling to map
            
            DEFAULT_CONFIG.FONT_WEIGHT = e.target.checked ? 'bold' : 'normal';
            stations.forEach(station => {
                const popupElement = station.popupMarker.getElement();
                if (popupElement) {
                    const infoBox = popupElement.querySelector('.info-box');
                    if (infoBox) {
                        infoBox.style.fontWeight = DEFAULT_CONFIG.FONT_WEIGHT;
                    }
                }
            });
        });

        DOM.defaultItalic.addEventListener('change', function(e) {
            e.stopPropagation();
            updateFontStyle(e.target.checked);
        });

        // Optimization: Delegate events to parent container
        document.getElementById('sidebar').addEventListener('click', function(e) {
            e.stopPropagation();
            
            // Event delegation for buttons and inputs
            if (e.target.matches('button, input')) {
                e.stopPropagation();
            }
        });

        // Helper function to update font style for all stations
        function updateFontStyle(isItalic) {
            DEFAULT_CONFIG.FONT_STYLE = isItalic ? 'italic' : 'normal';
            stations.forEach(updateStationStyle);
        }

        // Helper function to update individual station style
        function updateStationStyle(station) {
            const popupElement = station.popupMarker.getElement();
            if (!popupElement) return;
            
            const infoBox = popupElement.querySelector('.info-box');
            if (infoBox) {
                infoBox.style.fontStyle = DEFAULT_CONFIG.FONT_STYLE;
            }
        }
        
        // Prevent map click when interacting with sidebar
        document.getElementById('sidebar').addEventListener('click', (e) => {
            e.stopPropagation();
        });
    </script>
</body>

</html>
